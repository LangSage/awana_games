<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Maze Quest</title>
  <style>
    :root{
      --bg0:#070A14; --bg1:#0B1022; --text:#EAF0FF;
      --aqua:#5EE7FF; --mint:#61FFB6; --pink:#FF5FA3; --gold:#FFD166;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0;}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(900px 520px at 15% 10%, rgba(94,231,255,.18), transparent 58%),
        radial-gradient(880px 520px at 85% 15%, rgba(97,255,182,.12), transparent 60%),
        radial-gradient(900px 520px at 50% 92%, rgba(255,95,163,.10), transparent 64%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden;
    }
    canvas{
      position:fixed; inset:0; width:100vw; height:100vh; display:block;
      background:
        radial-gradient(900px 520px at 30% 20%, rgba(94,231,255,.10), transparent 60%),
        radial-gradient(900px 520px at 70% 30%, rgba(97,255,182,.07), transparent 62%),
        radial-gradient(900px 520px at 50% 90%, rgba(255,95,163,.06), transparent 64%),
        rgba(0,0,0,.18);
    }

    .hud{
      position:fixed;
      top: max(12px, env(safe-area-inset-top));
      left: max(12px, env(safe-area-inset-left));
      display:flex; gap:10px; align-items:center;
      padding:10px 12px; border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      user-select:none;
      z-index:5;
    }
    .pill{display:flex; gap:8px; align-items:center; font-weight:900; letter-spacing:.2px; white-space:nowrap;}
    .dot{width:10px; height:10px; border-radius:999px; background: var(--aqua); box-shadow: 0 0 0 4px rgba(94,231,255,.15);}
    .dot.keyNo{ background: var(--gold); box-shadow: 0 0 0 4px rgba(255,209,102,.15); }
    .dot.keyYes{ background: var(--mint); box-shadow: 0 0 0 4px rgba(97,255,182,.15); }

    /* BIG STRESS TIMER */
    .timerWrap{
      position:fixed;
      top: max(14px, env(safe-area-inset-top));
      left: 50%;
      transform: translateX(-50%);
      z-index:6;
      pointer-events:none;
      text-align:center;
    }
    .timer{
      display:inline-flex; align-items:center; justify-content:center;
      padding: 12px 16px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.34);
      backdrop-filter: blur(12px);
      box-shadow: 0 22px 80px rgba(0,0,0,.55);
      font-weight: 1000;
      letter-spacing: .6px;
      font-size: clamp(22px, 3.2vw, 44px);
      min-width: 190px;
      transform-origin: center;
    }
    .timerPulse{ animation: pulse 1s infinite ease-in-out; }
    @keyframes pulse{
      0%   { transform: scale(1);   filter: saturate(1); }
      50%  { transform: scale(1.06); filter: saturate(1.35); }
      100% { transform: scale(1);   filter: saturate(1); }
    }
    .timerHot{
      animation: pulseHot .62s infinite ease-in-out;
      border-color: rgba(255,95,163,.35);
      box-shadow: 0 22px 90px rgba(255,95,163,.18), 0 22px 80px rgba(0,0,0,.55);
    }
    @keyframes pulseHot{
      0%   { transform: scale(1); }
      50%  { transform: scale(1.085); }
      100% { transform: scale(1); }
    }

    .toast{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom: max(18px, env(safe-area-inset-bottom));
      padding:10px 12px; border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.38);
      backdrop-filter: blur(12px);
      font-weight:900; letter-spacing:.2px;
      opacity:0; pointer-events:none;
      transition: opacity .22s ease, transform .22s ease;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      text-align:center; max-width: 92%;
      white-space:pre-line;
      z-index:7;
    }
    .toast.show{opacity:1; transform: translateX(-50%) translateY(-2px);}
    audio{display:none;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="timerWrap">
    <div class="timer timerPulse" id="timerBox"><span id="uiTime">00:00.0</span></div>
  </div>

  <div class="hud">
    <div class="pill"><span class="dot"></span> <span id="uiLevel">1/3</span></div>
    <div class="pill"><span class="dot keyNo" id="keyDot"></span> <span id="uiKey">KEY: NO</span></div>
    <div class="pill"><span class="dot"></span> <span id="uiMoves">0</span></div>
  </div>

  <div class="toast" id="toast"></div>

  <audio id="sndCrash" src="crash.mp3" preload="auto"></audio>
  <audio id="sndStep"  src="step.mp3"  preload="auto"></audio>
  <audio id="sndKey"   src="key.mp3"   preload="auto"></audio>
  <audio id="sndWin"   src="win.mp3"   preload="auto"></audio>

<script>
(() => {
  const W = 16, H = 16;

  // ---- RNG (seeded) ----
  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---- Pathfinding (BFS) ----
  function bfsPath(grid, start, goal){
    const q = [];
    const prev = new Map();
    const key = (x,y) => x + "," + y;
    q.push(start);
    prev.set(key(start.x,start.y), null);

    while(q.length){
      const cur = q.shift();
      if(cur.x === goal.x && cur.y === goal.y) break;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx = cur.x + dx, ny = cur.y + dy;
        if(nx<0||ny<0||nx>=W||ny>=H) continue;
        if(grid[ny][nx] === "#") continue;
        const k = key(nx,ny);
        if(prev.has(k)) continue;
        prev.set(k, cur);
        q.push({x:nx,y:ny});
      }
    }

    const endKey = key(goal.x,goal.y);
    if(!prev.has(endKey)) return null;

    const path = [];
    let cur = goal;
    while(cur){
      path.push(cur);
      cur = prev.get(key(cur.x,cur.y));
    }
    path.reverse();
    return path;
  }

  // ---- Level generator (always solvable, not trivial) ----
  function generateLevel(seed){
    const rand = mulberry32(seed);
    const start = {x:1,y:1};
    const exit  = {x:14,y:14};

    // Try multiple times until we get a good-length path
    for(let attempt=0; attempt<400; attempt++){
      // Build random walls
      const grid = Array.from({length:H}, (_,y) =>
        Array.from({length:W}, (_,x) => {
          if(x===0||y===0||x===W-1||y===H-1) return "#"; // border
          return (rand() < 0.38) ? "#" : ".";
        })
      );

      // Ensure some space around start/exit
      const open3x3 = (cx,cy) => {
        for(let yy=cy-1; yy<=cy+1; yy++){
          for(let xx=cx-1; xx<=cx+1; xx++){
            if(xx<=0||yy<=0||xx>=W-1||yy>=H-1) continue;
            grid[yy][xx] = ".";
          }
        }
      };
      open3x3(start.x,start.y);
      open3x3(exit.x,exit.y);

      // Force a few “corridor” lines to avoid dead-ends-only triviality
      // (carve some lanes)
      for(let y=2; y<=13; y+=3){
        for(let x=1; x<=14; x++){
          if(rand() < 0.75) grid[y][x] = ".";
        }
      }
      for(let x=2; x<=13; x+=4){
        for(let y=1; y<=14; y++){
          if(rand() < 0.65) grid[y][x] = ".";
        }
      }

      // Make sure start/exit open
      grid[start.y][start.x] = ".";
      grid[exit.y][exit.x] = ".";

      // Find path S->E
      const path = bfsPath(grid, start, exit);
      if(!path) continue;

      // Difficulty control: require a decent path length
      if(path.length < 26 || path.length > 90) continue;

      // Choose key on the path (not too close to ends)
      const minIdx = Math.max(6, Math.floor(path.length * 0.35));
      const maxIdx = Math.min(path.length - 6, Math.floor(path.length * 0.70));
      const keyIdx = Math.max(minIdx, Math.min(maxIdx, minIdx + Math.floor(rand() * (maxIdx - minIdx + 1))));
      const keyPos = path[keyIdx];

      // Place S, K, E into a char-grid output
      const out = grid.map(row => row.slice());
      out[start.y][start.x] = "S";
      out[keyPos.y][keyPos.x] = "K";
      out[exit.y][exit.x] = "E";

      // Convert to array of 16 strings
      const lines = out.map(r => r.join(""));
      // Quick sanity: ensure K reachable from S and E reachable from K
      const g2 = lines.map(r => r.split("").map(ch => (ch==="S"||ch==="K"||ch==="E") ? "." : ch));
      const ok1 = bfsPath(g2, start, keyPos);
      const ok2 = bfsPath(g2, keyPos, exit);
      if(ok1 && ok2) return lines;
    }

    // Fallback (should never happen): a guaranteed solvable maze-ish layout
    return [
      "################",
      "#S....#...#....#",
      "#.##.#.#.#.##..#",
      "#..#.#.#.#..#..#",
      "##.#.#.#.##.#.##",
      "#..#...#....#..#",
      "#.#####.######.#",
      "#.....#......#.#",
      "#.###.####.#.#.#",
      "#...#....#.#...#",
      "###.##.#.#.###.#",
      "#....#.#.#.....#",
      "#.##.#.#.#####.#",
      "#..#...#....K#.#",
      "#.######.###E#.#",
      "################"
    ];
  }

  // Build 3 levels (same “difficulty settings”, different seeds)
  const LEVELS = [
    generateLevel(1337),
    generateLevel(2026),
    generateLevel(7777),
  ];

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const uiLevel = document.getElementById("uiLevel");
  const uiKey = document.getElementById("uiKey");
  const uiMoves = document.getElementById("uiMoves");
  const uiTime = document.getElementById("uiTime");
  const keyDot = document.getElementById("keyDot");
  const toast = document.getElementById("toast");
  const timerBox = document.getElementById("timerBox");

  const snd = {
    crash: document.getElementById("sndCrash"),
    step:  document.getElementById("sndStep"),
    key:   document.getElementById("sndKey"),
    win:   document.getElementById("sndWin")
  };

  const ICON_PLAYER = {
    body: new Path2D("M16 2 C10 2 6 7 6 12 C6 20 16 30 16 30 C16 30 26 20 26 12 C26 7 22 2 16 2 Z"),
    eye:  new Path2D("M13 12 a3 3 0 1 0 6 0 a3 3 0 1 0 -6 0")
  };
  const ICON_KEY = { shape: new Path2D("M20 8a6 6 0 1 0-5.2 9L13 19h-3v3H7v3H4v3h8v-3h3v-3h3l2.1-2.1A6 6 0 0 0 20 8Zm-6 0a2.5 2.5 0 1 1 5 0a2.5 2.5 0 0 1-5 0Z") };
  const ICON_DOOR = {
    frame: new Path2D("M7 2h18v28H7z"),
    hole:  new Path2D("M20 16a1.8 1.8 0 1 1-3.6 0a1.8 1.8 0 0 1 3.6 0Z"),
    inner: new Path2D("M10 4h12v24H10z")
  };

  const state = {
    levelIndex: 0,
    grid: [],
    tile: 28,
    offsetX: 0,
    offsetY: 0,
    player: {x:0,y:0},
    key: {x:0,y:0, taken:false},
    exit: {x:0,y:0},
    moves: 0,
    animT: 0,
    locked: false,
    stats: { goodMoves: 0, crashes: 0 },
    timer: { running:false, startMs:0, elapsedMs:0 }
  };

  let audioUnlocked = false;
  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audioUnlocked = true;
    Object.values(snd).forEach(a => {
      try{
        a.volume = 0;
        const p = a.play();
        if(p && p.then) p.then(()=>{ a.pause(); a.currentTime=0; a.volume=1; }).catch(()=>{ a.volume=1; });
        else { a.volume = 1; }
      } catch { a.volume = 1; }
    });
  }
  function playSound(aud, vol=0.9){
    if(!aud) return;
    try{ const node = aud.cloneNode(true); node.volume = vol; node.play().catch(()=>{}); } catch {}
  }
  function requestFs(){
    const el = document.documentElement;
    if(document.fullscreenElement) return;
    if(el.requestFullscreen) el.requestFullscreen().catch(()=>{});
  }

  function resetTimer(){
    state.timer.running = false;
    state.timer.startMs = 0;
    state.timer.elapsedMs = 0;
    uiTime.textContent = "00:00.0";
    timerBox.classList.remove("timerHot");
    timerBox.classList.add("timerPulse");
  }
  function startTimerIfNeeded(){
    if(state.timer.running) return;
    state.timer.running = true;
    state.timer.startMs = performance.now();
  }
  function stopTimer(){
    if(!state.timer.running) return;
    state.timer.elapsedMs += performance.now() - state.timer.startMs;
    state.timer.running = false;
  }
  function getElapsedMs(){
    return state.timer.running
      ? state.timer.elapsedMs + (performance.now() - state.timer.startMs)
      : state.timer.elapsedMs;
  }
  function formatTime(ms){
    const total = Math.max(0, ms);
    const m = Math.floor(total / 60000);
    const s = Math.floor((total % 60000) / 1000);
    const t = Math.floor((total % 1000) / 100);
    return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${t}`;
  }
  function updateTimerStress(ms){
    if(ms >= 60000){
      timerBox.classList.add("timerHot");
      timerBox.classList.remove("timerPulse");
    } else if(ms >= 30000){
      timerBox.classList.add("timerHot");
      timerBox.classList.remove("timerPulse");
    } else {
      timerBox.classList.remove("timerHot");
      timerBox.classList.add("timerPulse");
    }
  }

  function loadLevel(i, keepStats=true){
    state.levelIndex = i;
    state.grid = LEVELS[i].map(r => r.split(""));
    state.key.taken = false;
    state.moves = 0;
    state.locked = false;

    if(!keepStats){
      state.stats.goodMoves = 0;
      state.stats.crashes = 0;
      resetTimer();
    }

    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const ch = state.grid[y][x];
        if(ch === "S"){ state.player.x=x; state.player.y=y; state.grid[y][x]="."; }
        if(ch === "K"){ state.key.x=x; state.key.y=y; state.grid[y][x]="."; }
        if(ch === "E"){ state.exit.x=x; state.exit.y=y; state.grid[y][x]="."; }
      }
    }

    updateUI();
    fitCanvas();
    pop("");
  }

  function updateUI(){
    uiLevel.textContent = `${state.levelIndex+1}/3`;
    uiMoves.textContent = String(state.moves);
    if(state.key.taken){
      uiKey.textContent = "KEY: YES";
      keyDot.classList.remove("keyNo"); keyDot.classList.add("keyYes");
    } else {
      uiKey.textContent = "KEY: NO";
      keyDot.classList.add("keyNo"); keyDot.classList.remove("keyYes");
    }
  }

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;

    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const pad = 70; // bigger board (fills more)
    const availW = Math.max(100, cssW - pad*2);
    const availH = Math.max(100, cssH - pad*2);

    const tileW = Math.floor(availW / W);
    const tileH = Math.floor(availH / H);
    state.tile = Math.max(18, Math.min(tileW, tileH));

    const boardW = state.tile * W;
    const boardH = state.tile * H;

    state.offsetX = Math.floor((cssW - boardW)/2);
    state.offsetY = Math.floor((cssH - boardH)/2) + 20;
  }
  window.addEventListener("resize", fitCanvas);

  window.addEventListener("keydown", (e) => {
    unlockAudioOnce();
    requestFs();
    if(state.locked) return;

    const k = e.key;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(k)){
      e.preventDefault();
      const dx = (k==="ArrowLeft")?-1:(k==="ArrowRight")?1:0;
      const dy = (k==="ArrowUp")?-1:(k==="ArrowDown")?1:0;
      tryMove(dx,dy);
    }
    if(k === "r" || k === "R") loadLevel(state.levelIndex, true);
    if(k === "n" || k === "N") loadLevel(0, false);
  }, {passive:false});

  function isWall(x,y){
    if(x<0||y<0||x>=W||y>=H) return true;
    return state.grid[y][x] === "#";
  }

  let shakeT=0, shakeAmp=0;
  function shake(amp){ shakeT = 12; shakeAmp = amp; }

  let sparkles=[];
  function sparkle(tx,ty){
    const t=state.tile;
    for(let i=0;i<22;i++){
      sparkles.push({
        x:(tx+0.5)*t, y:(ty+0.5)*t,
        vx:(Math.random()*2-1)*2.8, vy:(Math.random()*2-1)*2.8,
        life: 28 + Math.random()*18
      });
    }
  }

  function tryMove(dx,dy){
    startTimerIfNeeded();

    const nx = state.player.x + dx;
    const ny = state.player.y + dy;

    if(isWall(nx,ny)){
      state.stats.crashes++;
      shake(4);
      playSound(snd.crash, 0.95);
      return;
    }

    state.player.x = nx; state.player.y = ny;
    state.moves++;
    state.stats.goodMoves++;
    updateUI();
    playSound(snd.step, 0.65);

    if(!state.key.taken && nx===state.key.x && ny===state.key.y){
      state.key.taken = true;
      updateUI();
      sparkle(nx,ny);
      playSound(snd.key, 0.90);
    }

    if(nx===state.exit.x && ny===state.exit.y){
      if(!state.key.taken){
        state.stats.crashes++;
        shake(5);
        playSound(snd.crash, 0.95);
      } else {
        winLevel();
      }
    }
  }

  function winLevel(){
    state.locked = true;
    sparkle(state.exit.x, state.exit.y);
    playSound(snd.win, 0.95);

    setTimeout(() => {
      const next = state.levelIndex + 1;
      if(next < 3){
        loadLevel(next, true);
        state.locked = false;
      } else {
        stopTimer();
        showEndStats();
      }
    }, 720);
  }

  function showEndStats(){
    const text =
      "FINISH ✅\n" +
      `TIME: ${formatTime(getElapsedMs())}\n` +
      `GOOD MOVES: ${state.stats.goodMoves}\n` +
      `CRASHES: ${state.stats.crashes}\n` +
      "\nN = restart all";
    pop(text);
    clearTimeout(pop._t);
    pop._t = setTimeout(()=> toast.classList.remove("show"), 7000);
    state.locked = false;
  }

  function pop(text){
    if(!text){ toast.classList.remove("show"); return; }
    toast.textContent = text;
    toast.classList.add("show");
    clearTimeout(pop._t);
    pop._t = setTimeout(()=> toast.classList.remove("show"), 900);
  }

  function roundRectFill(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.fill();
  }
  function roundRectStroke(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.stroke();
  }
  function drawPlatform(x,y,t,pulse,type){
    const px=x*t, py=y*t;
    const g = ctx.createRadialGradient(px+t/2, py+t/2, 2, px+t/2, py+t/2, t*0.95);
    if(type==="key"){
      g.addColorStop(0, `rgba(255,209,102,${0.22 + 0.12*pulse})`);
      g.addColorStop(1, "rgba(255,209,102,0.00)");
    } else {
      g.addColorStop(0, `rgba(94,231,255,${0.18 + 0.12*pulse})`);
      g.addColorStop(1, "rgba(94,231,255,0.00)");
    }
    ctx.fillStyle=g;
    ctx.fillRect(px-4, py-4, t+8, t+8);
  }
  function drawPlayer(cx,cy,size,pulse){
    const s=size/32;
    ctx.save(); ctx.translate(cx,cy);
    ctx.shadowColor="rgba(97,255,182,0.60)";
    ctx.shadowBlur=18;
    ctx.fillStyle=`rgba(97,255,182,${0.10 + 0.10*pulse})`;
    ctx.beginPath(); ctx.arc(0,0,size*0.50,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;

    ctx.scale(s,s); ctx.translate(-16,-16);
    const g=ctx.createLinearGradient(6,2,26,30);
    g.addColorStop(0,"rgba(94,231,255,0.98)");
    g.addColorStop(1,"rgba(97,255,182,0.88)");
    ctx.fillStyle=g;
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1.3;
    ctx.fill(ICON_PLAYER.body); ctx.stroke(ICON_PLAYER.body);
    ctx.fillStyle="rgba(0,0,0,0.45)"; ctx.fill(ICON_PLAYER.eye);
    ctx.fillStyle="rgba(255,255,255,0.65)";
    ctx.beginPath(); ctx.arc(18.3,11.2,1.3,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawIconKey(cx,cy,size,pulse){
    const s=size/32;
    ctx.save(); ctx.translate(cx,cy);
    ctx.shadowColor="rgba(255,209,102,0.75)";
    ctx.shadowBlur=18;
    ctx.fillStyle=`rgba(255,209,102,${0.10 + 0.12*pulse})`;
    ctx.beginPath(); ctx.arc(0,0,size*0.52,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;

    ctx.scale(s,s); ctx.translate(-16,-16);
    const g=ctx.createLinearGradient(6,6,28,28);
    g.addColorStop(0,"rgba(255,209,102,0.98)");
    g.addColorStop(1,"rgba(255,155,89,0.88)");
    ctx.fillStyle=g;
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1.1;
    ctx.fill(ICON_KEY.shape); ctx.stroke(ICON_KEY.shape);
    ctx.restore();
  }
  function drawIconDoor(cx,cy,size,unlocked,pulse){
    const s=size/32;
    ctx.save(); ctx.translate(cx,cy);
    ctx.shadowColor=unlocked ? "rgba(97,255,182,0.70)" : "rgba(255,95,163,0.65)";
    ctx.shadowBlur=18;
    ctx.fillStyle=unlocked ? `rgba(97,255,182,${0.08 + 0.10*pulse})` : `rgba(255,95,163,${0.08 + 0.10*pulse})`;
    ctx.beginPath(); ctx.arc(0,0,size*0.54,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;

    ctx.scale(s,s); ctx.translate(-16,-16);
    ctx.fillStyle="rgba(255,255,255,0.10)"; ctx.fill(ICON_DOOR.frame);
    const g=ctx.createLinearGradient(10,4,22,30);
    if(unlocked){ g.addColorStop(0,"rgba(97,255,182,0.58)"); g.addColorStop(1,"rgba(94,231,255,0.38)"); }
    else { g.addColorStop(0,"rgba(255,95,163,0.48)"); g.addColorStop(1,"rgba(94,231,255,0.22)"); }
    ctx.fillStyle=g; ctx.fill(ICON_DOOR.inner);
    ctx.strokeStyle="rgba(255,255,255,0.18)"; ctx.lineWidth=1.1; ctx.stroke(ICON_DOOR.frame);
    ctx.fillStyle=unlocked ? "rgba(0,0,0,0.38)" : "rgba(0,0,0,0.48)";
    ctx.fill(ICON_DOOR.hole);
    ctx.restore();
  }

  function draw(){
    state.animT += 0.016;

    const elapsed = getElapsedMs();
    uiTime.textContent = formatTime(elapsed);
    updateTimerStress(elapsed);

    const cssW=window.innerWidth, cssH=window.innerHeight;
    ctx.clearRect(0,0,cssW,cssH);

    const vign=ctx.createRadialGradient(cssW*0.5, cssH*0.45, 80, cssW*0.5, cssH*0.5, Math.max(cssW,cssH)*0.75);
    vign.addColorStop(0,"rgba(255,255,255,0.00)");
    vign.addColorStop(1,"rgba(0,0,0,0.46)");
    ctx.fillStyle=vign; ctx.fillRect(0,0,cssW,cssH);

    let sx=0, sy=0;
    if(shakeT>0){ shakeT--; sx=(Math.random()*2-1)*shakeAmp; sy=(Math.random()*2-1)*shakeAmp; }

    const t=state.tile, ox=state.offsetX+sx, oy=state.offsetY+sy;
    const pulse=0.5+0.5*Math.sin(state.animT*2.3);

    ctx.save(); ctx.translate(ox,oy);

    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const px=x*t, py=y*t;
        const wall=state.grid[y][x]==="#";
        if(wall){
          ctx.fillStyle="rgba(255,255,255,0.07)";
          roundRectFill(px+1,py+1,t-2,t-2,8);
          ctx.strokeStyle=`rgba(94,231,255,${0.14+0.12*pulse})`;
          ctx.lineWidth=1;
          roundRectStroke(px+1.5,py+1.5,t-3,t-3,8);
          ctx.strokeStyle="rgba(0,0,0,0.35)";
          ctx.lineWidth=2;
          ctx.strokeRect(px+1,py+1,t-2,t-2);
        } else {
          ctx.fillStyle="rgba(0,0,0,0.12)";
          roundRectFill(px+1,py+1,t-2,t-2,8);
          ctx.strokeStyle="rgba(255,255,255,0.05)";
          ctx.lineWidth=1;
          ctx.strokeRect(px+1.5,py+1.5,t-3,t-3);
        }
      }
    }

    drawPlatform(state.exit.x,state.exit.y,t,pulse,"door");
    if(!state.key.taken) drawPlatform(state.key.x,state.key.y,t,pulse,"key");

    if(!state.key.taken) drawIconKey((state.key.x+0.5)*t,(state.key.y+0.5)*t,t*0.92,pulse);
    drawIconDoor((state.exit.x+0.5)*t,(state.exit.y+0.5)*t,t*0.98,state.key.taken,pulse);
    drawPlayer((state.player.x+0.5)*t,(state.player.y+0.5)*t,t*0.98,pulse);

    for(let i=sparkles.length-1;i>=0;i--){
      const p=sparkles[i];
      p.x+=p.vx; p.y+=p.vy;
      p.vx*=0.955; p.vy*=0.955;
      p.life-=1;
      const a=Math.max(0,p.life/46);
      ctx.fillStyle=`rgba(255,209,102,${0.55*a})`;
      ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill();
      if(p.life<=0) sparkles.splice(i,1);
    }

    ctx.restore();
    requestAnimationFrame(draw);
  }

  // start
  loadLevel(0,false);
  fitCanvas();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
