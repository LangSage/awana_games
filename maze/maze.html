<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Maze Quest</title>
  <style>
    :root{
      --bg0:#070A14;
      --bg1:#0B1022;
      --text:#EAF0FF;
      --aqua:#5EE7FF;
      --mint:#61FFB6;
      --pink:#FF5FA3;
      --gold:#FFD166;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0;}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(900px 520px at 15% 10%, rgba(94,231,255,.18), transparent 58%),
        radial-gradient(880px 520px at 85% 15%, rgba(97,255,182,.12), transparent 60%),
        radial-gradient(900px 520px at 50% 92%, rgba(255,95,163,.10), transparent 64%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden;
    }

    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
      background:
        radial-gradient(900px 520px at 30% 20%, rgba(94,231,255,.10), transparent 60%),
        radial-gradient(900px 520px at 70% 30%, rgba(97,255,182,.07), transparent 62%),
        radial-gradient(900px 520px at 50% 90%, rgba(255,95,163,.06), transparent 64%),
        rgba(0,0,0,.18);
    }

    .hud{
      position:fixed;
      top: max(12px, env(safe-area-inset-top));
      left: max(12px, env(safe-area-inset-left));
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      user-select:none;
    }
    .pill{
      display:flex;
      gap:8px;
      align-items:center;
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--aqua);
      box-shadow: 0 0 0 4px rgba(94,231,255,.15);
    }
    .dot.keyNo{ background: var(--gold); box-shadow: 0 0 0 4px rgba(255,209,102,.15); }
    .dot.keyYes{ background: var(--mint); box-shadow: 0 0 0 4px rgba(97,255,182,.15); }

    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom: max(18px, env(safe-area-inset-bottom));
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.38);
      backdrop-filter: blur(12px);
      font-weight:900;
      letter-spacing:.2px;
      opacity:0;
      pointer-events:none;
      transition: opacity .22s ease, transform .22s ease;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      text-align:center;
      max-width: 92%;
      white-space:pre-line;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }
    audio{display:none;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="pill"><span class="dot"></span> <span id="uiLevel">1/3</span></div>
    <div class="pill"><span class="dot keyNo" id="keyDot"></span> <span id="uiKey">KEY: NO</span></div>
    <div class="pill"><span class="dot"></span> <span id="uiMoves">0</span></div>
  </div>

  <div class="toast" id="toast">...</div>

  <audio id="sndCrash" src="crash.mp3" preload="auto"></audio>
  <audio id="sndStep"  src="step.mp3"  preload="auto"></audio>
  <audio id="sndKey"   src="key.mp3"   preload="auto"></audio>
  <audio id="sndWin"   src="win.mp3"   preload="auto"></audio>

<script>
(() => {
  const LEVELS = [
    [
      "########################",
      "#S....#.......#.......#",
      "###.###.#####.#.#####.#",
      "#...#...#...#.#.....#.#",
      "#.###.###.#.#.#####.#.#",
      "#...#.....#.#.....#...#",
      "#.#.#######.#####.###.#",
      "#.#.......#.....#...#.#",
      "#.#######.#####.###.#.#",
      "#.......#.....#.#...#.#",
      "#######.#####.#.#.###.#",
      "#.....#.....#.#.#...#.#",
      "#.###.#####.#.#.###.#.#",
      "#...#.....#.#.#...#...#",
      "#.#####.#.#.#.###.###.#",
      "#.....#.#.#.#...#...#.#",
      "#.###.#.#.#.###.###.#.#",
      "#...#.#...#...#.....#.#",
      "#.#.#.#######.#######.#",
      "#.#.#.........#.....K.#",
      "#.#.###########.#####.#",
      "#.#.............#...E.#",
      "########################"
    ],
    [
      "########################",
      "#S....#.......#.......#",
      "###.###.#####.#.#####.#",
      "#...#...#...#.#.....#.#",
      "#.###.###.#.#.#####.#.#",
      "#...#.....#.#.....#...#",
      "#.#.#######.#####.###.#",
      "#.#...#.....#...#...#.#",
      "#.###.#.#####.#.###.#.#",
      "#...#.#.....#.#...#...#",
      "###.#.#####.#.###.###.#",
      "#...#.....#.#...#.....#",
      "#.#######.#.###.#####.#",
      "#.......#.#...#.....#.#",
      "#######.#.###.###.#.#.#",
      "#.....#.#...#...#.#.#.#",
      "#.###.#.###.###.#.#.#.#",
      "#...#.#...#.....#.#...#",
      "#.#.#.###.#######.###.#",
      "#.#...#...#.....K...#.#",
      "#.#####.###.#########.#",
      "#.......#.....E.......#",
      "########################"
    ],
    [
      "########################",
      "#S....#.......#.......#",
      "###.###.#####.#.#####.#",
      "#...#...#...#.#.....#.#",
      "#.###.###.#.#.#####.#.#",
      "#...#.....#.#.....#...#",
      "#.#.#######.#####.###.#",
      "#.#.....#...#.....#...#",
      "#.#####.#.###.#####.###",
      "#.....#.#...#.....#...#",
      "###.#.#.###.#####.#.###",
      "#...#.#...#.....#.#...#",
      "#.###.###.#####.#.###.#",
      "#...#.....#...#.#.....#",
      "#.#########.#.#.#######",
      "#.....#.....#.#.......#",
      "#.###.#.#####.#######.#",
      "#...#.#.....#.....#...#",
      "###.#.#####.#####.#.###",
      "#...#.....#.....#.#...#",
      "#.#######.#####.#.###.#",
      "#.....K.........#...E.#",
      "########################"
    ]
  ];

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const uiLevel = document.getElementById("uiLevel");
  const uiKey = document.getElementById("uiKey");
  const uiMoves = document.getElementById("uiMoves");
  const keyDot = document.getElementById("keyDot");
  const toast = document.getElementById("toast");

  const snd = {
    crash: document.getElementById("sndCrash"),
    step:  document.getElementById("sndStep"),
    key:   document.getElementById("sndKey"),
    win:   document.getElementById("sndWin")
  };

  const ICON_PLAYER = {
    body: new Path2D("M16 2 C10 2 6 7 6 12 C6 20 16 30 16 30 C16 30 26 20 26 12 C26 7 22 2 16 2 Z"),
    eye:  new Path2D("M13 12 a3 3 0 1 0 6 0 a3 3 0 1 0 -6 0")
  };
  const ICON_KEY = { shape: new Path2D("M20 8a6 6 0 1 0-5.2 9L13 19h-3v3H7v3H4v3h8v-3h3v-3h3l2.1-2.1A6 6 0 0 0 20 8Zm-6 0a2.5 2.5 0 1 1 5 0a2.5 2.5 0 0 1-5 0Z") };
  const ICON_DOOR = {
    frame: new Path2D("M7 2h18v28H7z"),
    hole:  new Path2D("M20 16a1.8 1.8 0 1 1-3.6 0a1.8 1.8 0 0 1 3.6 0Z"),
    inner: new Path2D("M10 4h12v24H10z")
  };

  const state = {
    levelIndex: 0,
    grid: [],
    w: 0,
    h: 0,
    tile: 22,
    offsetX: 0,
    offsetY: 0,
    player: {x:0,y:0},
    key: {x:0,y:0, taken:false},
    exit: {x:0,y:0},
    moves: 0,
    animT: 0,
    locked: false,
    // stats (whole run across 3 levels)
    stats: {
      goodMoves: 0,
      crashes: 0
    }
  };

  let audioUnlocked = false;
  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audioUnlocked = true;
    Object.values(snd).forEach(a => {
      try{
        a.volume = 0;
        const p = a.play();
        if(p && p.then) p.then(()=>{ a.pause(); a.currentTime=0; a.volume=1; }).catch(()=>{ a.volume=1; });
        else { a.volume = 1; }
      } catch { a.volume = 1; }
    });
  }

  function playSound(aud, vol=0.9){
    if(!aud) return;
    try{
      const node = aud.cloneNode(true);
      node.volume = vol;
      node.play().catch(()=>{});
    } catch {}
  }

  function requestFs(){
    const el = document.documentElement;
    if(document.fullscreenElement) return;
    if(el.requestFullscreen) el.requestFullscreen().catch(()=>{});
  }

  function loadLevel(i, keepStats=true){
    state.levelIndex = i;
    const raw = LEVELS[i];
    state.h = raw.length;
    state.w = raw[0].length;
    state.grid = raw.map(r => r.split(""));
    state.key.taken = false;
    state.moves = 0;
    state.locked = false;

    if(!keepStats){
      state.stats.goodMoves = 0;
      state.stats.crashes = 0;
    }

    for(let y=0;y<state.h;y++){
      for(let x=0;x<state.w;x++){
        const ch = state.grid[y][x];
        if(ch === "S"){ state.player.x=x; state.player.y=y; state.grid[y][x]="."; }
        if(ch === "K"){ state.key.x=x; state.key.y=y; state.grid[y][x]="."; }
        if(ch === "E"){ state.exit.x=x; state.exit.y=y; state.grid[y][x]="."; }
      }
    }

    updateUI();
    fitCanvas();
    pop("");
  }

  function updateUI(){
    uiLevel.textContent = `${state.levelIndex+1}/3`;
    uiMoves.textContent = String(state.moves);
    if(state.key.taken){
      uiKey.textContent = "KEY: YES";
      keyDot.classList.remove("keyNo");
      keyDot.classList.add("keyYes");
    } else {
      uiKey.textContent = "KEY: NO";
      keyDot.classList.add("keyNo");
      keyDot.classList.remove("keyYes");
    }
  }

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;

    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // Even smaller maze: bigger padding + extra downscale on tile
    const pad = 78;
    const availW = cssW - pad*2;
    const availH = cssH - pad*2;

    const tileW = Math.floor(availW / state.w);
    const tileH = Math.floor(availH / state.h);
    state.tile = Math.max(12, Math.min(tileW, tileH) - 3);

    const mazePxW = state.tile * state.w;
    const mazePxH = state.tile * state.h;

    state.offsetX = Math.floor((cssW - mazePxW)/2);
    state.offsetY = Math.floor((cssH - mazePxH)/2);
  }
  window.addEventListener("resize", fitCanvas);

  // Input
  window.addEventListener("keydown", (e) => {
    unlockAudioOnce();
    requestFs();

    if(state.locked) return;

    const k = e.key;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(k)){
      e.preventDefault();
      const dx = (k==="ArrowLeft")?-1:(k==="ArrowRight")?1:0;
      const dy = (k==="ArrowUp")?-1:(k==="ArrowDown")?1:0;
      tryMove(dx,dy);
    }
    if(k === "r" || k === "R"){
      // restart current level only (keep total stats)
      loadLevel(state.levelIndex, true);
    }
    if(k === "n" || k === "N"){
      // restart whole run (reset stats)
      loadLevel(0, false);
    }
  }, {passive:false});

  function isWall(x,y){
    if(x<0||y<0||x>=state.w||y>=state.h) return true;
    return state.grid[y][x] === "#";
  }

  function tryMove(dx,dy){
    const nx = state.player.x + dx;
    const ny = state.player.y + dy;

    if(isWall(nx,ny)){
      state.stats.crashes++;
      shake(3);
      playSound(snd.crash, 0.95);
      return;
    }

    state.player.x = nx;
    state.player.y = ny;
    state.moves++;
    state.stats.goodMoves++;
    updateUI();
    playSound(snd.step, 0.65);

    if(!state.key.taken && nx === state.key.x && ny === state.key.y){
      state.key.taken = true;
      updateUI();
      sparkle(nx, ny);
      playSound(snd.key, 0.90);
    }

    if(nx === state.exit.x && ny === state.exit.y){
      if(!state.key.taken){
        state.stats.crashes++; // treat locked-door bump as a "crash" feedback
        shake(4);
        playSound(snd.crash, 0.95);
      } else {
        winLevel();
      }
    }
  }

  function winLevel(){
    state.locked = true;
    sparkle(state.exit.x, state.exit.y);
    playSound(snd.win, 0.95);

    setTimeout(() => {
      const next = state.levelIndex + 1;
      if(next < LEVELS.length){
        loadLevel(next, true);
        state.locked = false;
      } else {
        // end screen (stats)
        showEndStats();
      }
    }, 720);
  }

  function showEndStats(){
    const text =
      "FINISH âœ…\n" +
      `GOOD MOVES: ${state.stats.goodMoves}\n` +
      `CRASHES: ${state.stats.crashes}\n` +
      "\nN = restart all";
    pop(text);
    // keep final visible longer
    clearTimeout(pop._t);
    pop._t = setTimeout(()=> toast.classList.remove("show"), 5000);
    // unlock after showing (player can press N)
    state.locked = false;
  }

  // FX
  let shakeT = 0, shakeAmp = 0;
  function shake(amp){ shakeT = 12; shakeAmp = amp; }

  let sparkles = [];
  function sparkle(tx, ty){
    const t = state.tile;
    for(let i=0;i<22;i++){
      sparkles.push({
        x:(tx+0.5) * t,
        y:(ty+0.5) * t,
        vx:(Math.random()*2-1)*2.5,
        vy:(Math.random()*2-1)*2.5,
        life: 30 + Math.random()*14
      });
    }
  }

  function pop(text){
    if(!text){
      toast.classList.remove("show");
      return;
    }
    toast.textContent = text;
    toast.classList.add("show");
    clearTimeout(pop._t);
    pop._t = setTimeout(()=> toast.classList.remove("show"), 900);
  }

  // Render helpers
  function roundRectFill(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.fill();
  }
  function roundRectStroke(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.stroke();
  }
  function drawPlatform(x,y,t,pulse,type){
    const px = x*t, py=y*t;
    const g = ctx.createRadialGradient(px+t/2, py+t/2, 2, px+t/2, py+t/2, t*0.9);
    if(type==="key"){
      g.addColorStop(0, `rgba(255,209,102,${0.20 + 0.10*pulse})`);
      g.addColorStop(1, "rgba(255,209,102,0.00)");
    } else {
      g.addColorStop(0, `rgba(94,231,255,${0.16 + 0.10*pulse})`);
      g.addColorStop(1, "rgba(94,231,255,0.00)");
    }
    ctx.fillStyle = g;
    ctx.fillRect(px-3, py-3, t+6, t+6);
  }

  function drawPlayer(cx, cy, size, pulse){
    const s = size / 32;
    ctx.save();
    ctx.translate(cx, cy);

    ctx.shadowColor = "rgba(97,255,182,0.55)";
    ctx.shadowBlur = 16;
    ctx.fillStyle = `rgba(97,255,182,${0.11 + 0.08*pulse})`;
    ctx.beginPath();
    ctx.arc(0, 0, size*0.44, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.scale(s, s);
    ctx.translate(-16, -16);

    const bodyGrad = ctx.createLinearGradient(6, 2, 26, 30);
    bodyGrad.addColorStop(0, "rgba(94,231,255,0.95)");
    bodyGrad.addColorStop(1, "rgba(97,255,182,0.85)");
    ctx.fillStyle = bodyGrad;
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.4;

    ctx.fill(ICON_PLAYER.body);
    ctx.stroke(ICON_PLAYER.body);

    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fill(ICON_PLAYER.eye);
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.beginPath(); ctx.arc(18.3, 11.2, 1.3, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawIconKey(cx, cy, size, pulse){
    const s = size / 32;
    ctx.save();
    ctx.translate(cx, cy);

    ctx.shadowColor = "rgba(255,209,102,0.65)";
    ctx.shadowBlur = 16;
    ctx.fillStyle = `rgba(255,209,102,${0.10 + 0.10*pulse})`;
    ctx.beginPath();
    ctx.arc(0, 0, size*0.48, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.scale(s, s);
    ctx.translate(-16, -16);

    const g = ctx.createLinearGradient(6, 6, 28, 28);
    g.addColorStop(0, "rgba(255,209,102,0.95)");
    g.addColorStop(1, "rgba(255,155,89,0.85)");
    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.2;

    ctx.fill(ICON_KEY.shape);
    ctx.stroke(ICON_KEY.shape);

    ctx.restore();
  }

  function drawIconDoor(cx, cy, size, unlocked, pulse){
    const s = size / 32;
    ctx.save();
    ctx.translate(cx, cy);

    ctx.shadowColor = unlocked ? "rgba(97,255,182,0.60)" : "rgba(255,95,163,0.55)";
    ctx.shadowBlur = 16;
    ctx.fillStyle = unlocked
      ? `rgba(97,255,182,${0.09 + 0.08*pulse})`
      : `rgba(255,95,163,${0.09 + 0.08*pulse})`;
    ctx.beginPath();
    ctx.arc(0, 0, size*0.50, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.scale(s, s);
    ctx.translate(-16, -16);

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fill(ICON_DOOR.frame);

    const g = ctx.createLinearGradient(10, 4, 22, 30);
    if(unlocked){
      g.addColorStop(0, "rgba(97,255,182,0.55)");
      g.addColorStop(1, "rgba(94,231,255,0.35)");
    } else {
      g.addColorStop(0, "rgba(255,95,163,0.45)");
      g.addColorStop(1, "rgba(94,231,255,0.20)");
    }
    ctx.fillStyle = g;
    ctx.fill(ICON_DOOR.inner);

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.2;
    ctx.stroke(ICON_DOOR.frame);

    ctx.fillStyle = unlocked ? "rgba(0,0,0,0.38)" : "rgba(0,0,0,0.48)";
    ctx.fill(ICON_DOOR.hole);

    ctx.restore();
  }

  // Draw loop
  function draw(){
    state.animT += 0.016;

    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    ctx.clearRect(0,0,cssW,cssH);

    // vignette
    ctx.save();
    const grad = ctx.createRadialGradient(cssW*0.5, cssH*0.45, 80, cssW*0.5, cssH*0.5, Math.max(cssW,cssH)*0.7);
    grad.addColorStop(0, "rgba(255,255,255,0.00)");
    grad.addColorStop(1, "rgba(0,0,0,0.42)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,cssW,cssH);
    ctx.restore();

    // shake
    let sx=0, sy=0;
    if(shakeT>0){
      shakeT--;
      sx = (Math.random()*2-1) * shakeAmp;
      sy = (Math.random()*2-1) * shakeAmp;
    }

    const t = state.tile;
    const ox = state.offsetX + sx;
    const oy = state.offsetY + sy;
    const pulse = 0.5 + 0.5*Math.sin(state.animT*2.2);

    ctx.save();
    ctx.translate(ox, oy);

    for(let y=0;y<state.h;y++){
      for(let x=0;x<state.w;x++){
        const px = x*t, py = y*t;
        const wall = state.grid[y][x] === "#";

        if(wall){
          ctx.fillStyle = "rgba(255,255,255,0.07)";
          roundRectFill(px+1, py+1, t-2, t-2, 7);

          ctx.strokeStyle = `rgba(94,231,255,${0.14 + 0.10*pulse})`;
          ctx.lineWidth = 1;
          roundRectStroke(px+1.5, py+1.5, t-3, t-3, 7);

          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 2;
          ctx.strokeRect(px+1, py+1, t-2, t-2);
        } else {
          ctx.fillStyle = "rgba(0,0,0,0.12)";
          roundRectFill(px+1, py+1, t-2, t-2, 7);
          ctx.strokeStyle = "rgba(255,255,255,0.05)";
          ctx.lineWidth = 1;
          ctx.strokeRect(px+1.5, py+1.5, t-3, t-3);
        }
      }
    }

    drawPlatform(state.exit.x, state.exit.y, t, pulse, "door");
    if(!state.key.taken) drawPlatform(state.key.x, state.key.y, t, pulse, "key");

    if(!state.key.taken) drawIconKey((state.key.x+0.5)*t, (state.key.y+0.5)*t, t*0.92, pulse);
    drawIconDoor((state.exit.x+0.5)*t, (state.exit.y+0.5)*t, t*0.98, state.key.taken, pulse);
    drawPlayer((state.player.x+0.5)*t, (state.player.y+0.5)*t, t*0.98, pulse);

    for(let i=sparkles.length-1;i>=0;i--){
      const p = sparkles[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.96; p.vy *= 0.96;
      p.life -= 1;
      const a = Math.max(0, p.life/44);
      ctx.fillStyle = `rgba(255,209,102,${0.55*a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.1, 0, Math.PI*2);
      ctx.fill();
      if(p.life<=0) sparkles.splice(i,1);
    }

    ctx.restore();
    requestAnimationFrame(draw);
  }

  // Start
  loadLevel(0, false);
  fitCanvas();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
